{"version":3,"sources":["parsertools.coffee"],"names":[],"mappings":"AAAA;AAAA;;;GAAA;AAAA;AAAA;AAAA,MAAA,4DAAA;;AAAA,EAKA,MAAA,GAAS,OAAA,CAAQ,UAAR,CALT,CAAA;;AAAA,EAYA,GAAA,GAAM,SAAC,CAAD,EAAI,CAAJ,GAAA;AACL,IAAA,CAAA,GAAI,OAAA,CAAQ,CAAR,CAAJ,CAAA;AAAA,IACA,CAAA,GAAI,OAAA,CAAQ,CAAR,CADJ,CAAA;WAEA,CAAC,CAAC,GAAF,CAAM,CAAN,EAHK;EAAA,CAZN,CAAA;;AAAA,EAsBA,GAAA,GAAM,SAAC,CAAD,EAAI,CAAJ,GAAA;AACL,IAAA,CAAA,GAAI,OAAA,CAAQ,CAAR,CAAJ,CAAA;AAAA,IACA,CAAA,GAAI,OAAA,CAAQ,CAAR,CADJ,CAAA;WAEA,CAAC,CAAC,GAAF,CAAM,CAAN,EAHK;EAAA,CAtBN,CAAA;;AAAA,EAgCA,IAAA,GAAO,SAAC,CAAD,EAAI,CAAJ,GAAA;AACN,IAAA,CAAA,GAAI,OAAA,CAAQ,CAAR,CAAJ,CAAA;AAAA,IACA,CAAA,GAAI,OAAA,CAAQ,CAAR,CADJ,CAAA;WAEA,CAAC,CAAC,IAAF,CAAO,CAAP,EAHM;EAAA,CAhCP,CAAA;;AAAA,EA0CA,GAAA,GAAM,SAAC,CAAD,EAAI,CAAJ,GAAA;AACL,IAAA,CAAA,GAAI,OAAA,CAAQ,CAAR,CAAJ,CAAA;AAAA,IACA,CAAA,GAAI,OAAA,CAAQ,CAAR,CADJ,CAAA;WAEA,CAAC,CAAC,GAAF,CAAM,CAAN,EAHK;EAAA,CA1CN,CAAA;;AAAA,EAoDA,GAAA,GAAM,SAAC,IAAD,EAAO,GAAP,GAAA;AACL,IAAA,IAAG,GAAA,YAAe,MAAM,CAAC,aAAtB,IAAwC,GAAG,CAAC,MAAJ,KAAc,CAAzD;AAAgE,YAAM,8BAAN,CAAhE;KAAA;AAAA,IACA,GAAA,GAAS,GAAA,YAAe,MAAM,CAAC,aAAzB,GAA4C,GAAG,CAAC,MAAhD,GAA4D,GADlE,CAAA;AAAA,IAEA,IAAA,GAAO,OAAA,CAAQ,IAAR,CAFP,CAAA;WAGA,IAAI,CAAC,GAAL,CAAS,GAAT,EAJK;EAAA,CApDN,CAAA;;AAAA,EA8DA,SAAA,GAAY,SAAC,CAAD,GAAA;AACX,IAAA,IAAG,CAAA,YAAa,MAAM,CAAC,aAAvB;aAA0C,CAAC,CAAC,SAAF,CAAA,EAA1C;KAAA,MAAA;aAA6D,EAA7D;KADW;EAAA,CA9DZ,CAAA;;AAAA,EAqEA,MAAA,GAAS,SAAC,MAAD,EAAS,UAAT,GAAA;WACJ,IAAA,MAAM,CAAC,aAAP,CAAqB,MAArB,EAA6B,UAA7B,EADI;EAAA,CArET,CAAA;;AAAA,EAwEA,OAAA,GAAU,SAAC,CAAD,GAAA;AACT,IAAA,IAAG,CAAA,CAAE,CAAA,YAAa,MAAM,CAAC,aAArB,CAAJ;aAA6C,MAAA,CAAO,CAAP,EAAU,CAAV,EAA7C;KAAA,MAAA;aAA+D,EAA/D;KADS;EAAA,CAxEV,CAAA;;AAAA,EA2EA,MAAM,CAAC,OAAP,GAAiB;AAAA,IAAC,KAAA,GAAD;AAAA,IAAM,KAAA,GAAN;AAAA,IAAW,MAAA,IAAX;AAAA,IAAiB,KAAA,GAAjB;AAAA,IAAsB,KAAA,GAAtB;AAAA,IAA2B,QAAA,MAA3B;AAAA,IAAmC,WAAA,SAAnC;AAAA,IAA8C,SAAA,OAA9C;GA3EjB,CAAA;AAAA","file":"parsertools.js","sourceRoot":"/source/","sourcesContent":["###\n# Glue code between Physik-Library and parser\n# @author David Bohn <david.bohn@cancrisoft.net>\n###\n\nPhysik = require('./physik');\n\n# Adds two values, which should be either ErrorIntervals or numerical values\n#\n# @param [Float|Physik.ErrorInterval] Should be a ErrorInterval, otherwise it will be converted\n# @param [Float|Physik.ErrorInterval] Should be a ErrorInterval, otherwise it will be converted\n# @return [Physik.ErrorInterval] The sum of a and b\nadd = (a, b) ->\n\ta = convVal(a)\n\tb = convVal(b)\n\ta.add(b)\n\n# Subtracts two values, which should be either ErrorIntervals or numerical values\n#\n# @param [Float|Physik.ErrorInterval] Should be a ErrorInterval, otherwise it will be converted\n# @param [Float|Physik.ErrorInterval] Should be a ErrorInterval, otherwise it will be converted\n# @return [Physik.ErrorInterval] The sum of a and b\nsub = (a, b) ->\n\ta = convVal(a)\n\tb = convVal(b)\n\ta.sub(b)\n\n# Mutliplies two values, which should be either ErrorIntervals or numerical values\n#\n# @param [Float|Physik.ErrorInterval] Should be a ErrorInterval, otherwise it will be converted\n# @param [Float|Physik.ErrorInterval] Should be a ErrorInterval, otherwise it will be converted\n# @return [Physik.ErrorInterval] The sum of a and b\nmult = (a, b) ->\n\ta = convVal(a)\n\tb = convVal(b)\n\ta.mult(b)\n\n# Divides a by b, which should be either ErrorIntervals or numerical values\n#\n# @param [Float|Physik.ErrorInterval] Should be a ErrorInterval, otherwise it will be converted\n# @param [Float|Physik.ErrorInterval] Should be a ErrorInterval, otherwise it will be converted\n# @return [Physik.ErrorInterval] The sum of a and b\ndiv = (a, b) ->\n\ta = convVal(a)\n\tb = convVal(b)\n\ta.div(b)\n\n# Calculates base to the power of exp\n#\n# @param [Float|Physik.ErrorInterval] Should be a ErrorInterval, otherwise it will be converted\n# @param [Float|Physik.ErrorInterval] If it is an ErrorInterval, the radius *must* be 0\n# @return [Physik.ErrorInterval] base^exp\npow = (base, exp) ->\n\tif exp instanceof Physik.ErrorInterval and exp.radius != 0 then throw 'Exponent must not have error'\n\texp = if exp instanceof Physik.ErrorInterval then exp.median else exp\n\tbase = convVal(base)\n\tbase.pow(exp)\n\n# If the given parameter is an ErrorInterval, a valid representation for a end result will be\n# generated. Otherwise itself will be returned\n#\n# @param [Physik.ErrorInterval|Float] Formats an ErrorInterval according the rules\nendResult = (a) ->\n\tif a instanceof Physik.ErrorInterval then a.endResult() else a\n\n# Creates a new ErrorInterval\n#\n# @param [Float] The main value\n# @param [Float] The error radius around the main value\ncreate = (median, derivation) ->\n\tnew Physik.ErrorInterval(median, derivation)\n\nconvVal = (a) ->\n\tif !(a instanceof Physik.ErrorInterval) then create(a, 0) else a\n\nmodule.exports = {add, sub, mult, div, pow, create, endResult, convVal}"]}